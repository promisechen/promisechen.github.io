

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>suricata4.0.1源码分析 &mdash; 陈令祥文档系统 1.0.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  

  
    <link rel="top" title="陈令祥文档系统 1.0.0 文档" href="../index.html"/>
        <link rel="up" title="suricata" href="index.html"/>
        <link rel="next" title="源码笔记(3.2.1)" href="review.html"/>
        <link rel="prev" title="快速使用" href="quick_start.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> 陈令祥文档系统
          

          
            
            <img src="../_static/logo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../doc_guide/index.html">文档编写指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../doc_guide/howto.html">1. 如何用sphinx+reST编写文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#id1">1.1. 前言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#id2">1.2. 安装软件包</a></li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#id3">1.3. 项目建立</a></li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#conf-py">1.4. conf.py配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id4">1.4.1. 主题样式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#logo">1.4.2. LOGO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id5">1.4.3. 不显示源文件链接</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#index">1.5. index页配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#id6">1.6. 修改默认样式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#step1">1.6.1. Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#step2">1.6.2. Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#step3">1.6.3. Step3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#api">1.7. 生成API文档</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id7">1.7.1. Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id8">1.7.2. Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id9">1.7.3. Step3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#step4">1.7.4. Step4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#pdf">1.8. 生成PDF</a></li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#rest">1.9. reST语法介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id10">1.9.1. 章节标题</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id11">1.9.2. 段落</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id12">1.9.3. 行内标记</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id13">1.9.4. 列表</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id14">1.9.5. 代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id15">1.9.6. 超链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id16">1.9.7. 图片</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id17">1.9.8. 表格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id18">1.9.9. 引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id19">1.9.10. 脚注</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id20">1.9.11. 提醒</a></li>
<li class="toctree-l4"><a class="reference internal" href="../doc_guide/howto.html#id21">1.9.12. 替换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/howto.html#id22">1.10. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../doc_guide/dir_struct.html">2. 目录结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../doc_guide/dir_struct.html#id2">2.1. 概述</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../kbase/index.html">技术知识</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../kbase/cunit.html">CUnit测试工具</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id1">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id2">安装配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/cunit.html#ubuntu">Ubuntu</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/cunit.html#id3">从源码编译</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id4">输出方式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/cunit.html#void-cu-automated-run-tests-void">void CU_automated_run_tests(void)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/cunit.html#cu-errorcode-cu-list-tests-to-file-void">CU_ErrorCode CU_list_tests_to_file(void)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/cunit.html#void-cu-set-output-filename-const-char-szfilenameroot">void CU_set_output_filename(const char* szFilenameRoot)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id5">断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id6">错误处理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/cunit.html#id7">参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/gdb.html">gdb速查手册</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/gdb.html#id1">常用命令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/gdb.html#id2">常见汇编指令</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/gdb.html#id3">调试技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/gdb.html#id4">图形界面使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/gdb.html#id5">内存断点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/gdb.html#id6">启动自加载断点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/gdb.html#dmesg">通过dmesg查看段错误位置</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/gdb.html#c">定位到c代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/netalgo/index.html">网络算法学</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/netalgo/proto_process.html">9 Protocol Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/proto_process.html#id1">9.1 缓存管理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/proto_process.html#crcchecksum">9.2 CRC和Checksum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/proto_process.html#id4">9.3 通用协议处理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/proto_process.html#id5">9.4 重组</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/netalgo/sched_packet.html">14 Scheduling Packets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id1">14.1 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id2">14.2 拥塞控制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id13">14.3 带宽与突发限制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id24">14.4 多队列与优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id25">14.5 资源预留协议</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id26">14.6 带宽保证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id30">14.7 时延保证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#scalable-fair-queuing">14.8 Scalable Fair Queuing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#dpdk">14.9 dpdk分层调度</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#diffserv">14.10 DiffServ架构介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#dpdk-qos">14.11 dpdk QoS框架</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id37">附录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/netalgo/sched_packet.html#id38">参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/ntp.html">NTP服务器客户端配置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ntp.html#id1">目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ntp.html#id2">读者</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ntp.html#id3">名词</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ntp.html#id4">专有名词</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ntp.html#id5">服务器/客户端配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ntp.html#id6">服务器端配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ntp.html#id7">客户端配置</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ntp.html#id8">同步时间</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/ipmi.html">IPMI概述</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id1">1 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id2">2 名词解释</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id3">3 主要功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id4">4 IPMI管理工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id5">4.1 安装管理工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id6">4.2 加载IPMI内核</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id7">5 IPMI命令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#ipmitool">5.1 ipmitool命令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id8">5.2 常用命令模板</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/ipmi.html#id9">6、远程管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#bmc">6.1 设置BMC信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id10">6.2 配置用户</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id11">6.3 查看bmc信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/ipmi.html#id12">6.4 远程操作</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/redis.html">redis性能测试</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/redis.html#id1">1 测试说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../kbase/redis.html#id2">1.1 测试环境</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/redis.html#id3">1.2 测试用例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../kbase/redis.html#id7">1.3.    测试总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kbase/xiaomi.html">小米路由器上开发网络监控程序</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#mini">小米路由器mini刷机</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#ssh">开启ssh</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#id3">开发环境搭建</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#libpcap">交叉编译libpcap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#id5">远程抓包</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kbase/xiaomi.html#gdb">gdb调试</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dpdk/index.html">dpdk相关</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/init.html">dpdk源码分析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#log">log</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#rte-eal-cpu-init">rte_eal_cpu_init</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id1">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id2">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id3">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#eal-parse-args">eal_parse_args</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id4">相关的外部接口和变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id5">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id6">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#eal-hugepage-info-init">eal_hugepage_info_init</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id7">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id8">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id9">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#rte-config-init">rte_config_init</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id10">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id11">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id12">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#rte-eal-pci-init-todo">rte_eal_pci_init(todo)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id13">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id14">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id15">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#rte-eal-memory-init">rte_eal_memory_init</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id16">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id17">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id18">主要接口描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/init.html#rte-eal-hugepage-init">rte_eal_hugepage_init</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id19">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id20">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id21">主要接口描述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id22">样例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id23">相关的外部接口及变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id24">函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/init.html#id25">主要接口描述</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/zp/index.html">DPDK Library(转载fromhttps://github.com/zzqcn/)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/eal.html">EAL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#linuxeal">Linux环境的EAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#id1">内存机制与初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#cpu">CPU信息取得与核绑定</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#lcore">线程/lcore的初始化与启动</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#id2">多进程应用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#id3">其他注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/eal.html#id4">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/ring.html">Ring</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id4">应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id5">无锁队列操作图解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id6">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id7">多生产者入队</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id8">多消费者出队</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id9">索引计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/ring.html#id10">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/mem.html">Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mem.html#id1">内存的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mem.html#id6">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/memseg.html">Memseg</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memseg.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memseg.html#id2">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memseg.html#id3">初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/memzone.html">Memzone</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memzone.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memzone.html#memzone-init">初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memzone.html#id3">内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memzone.html#id4">内存释放</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/memzone.html#id5">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/malloc.html">Malloc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#id2">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#malloc-heap">malloc heap初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#malloc-heap-alloc">内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#id4">内存释放</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/malloc.html#id5">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/mempool.html">Mempool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id2">特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id4">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id5">创建</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id6">取出对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id7">还回对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mempool.html#id8">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/zp/mbuf.html">Mbuf</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id2">原理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id3">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id4">分配与回收</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id8">元信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#directindirect-mbuf">Direct和Indirect mbuf</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/zp/mbuf.html#id9">参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/index.html#id1">杂记</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/index.html#id2">dpdk示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/index.html#rst">rst</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/index.html#dpdkmakefile">dpdkmakefile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/index.html#test-mirror">test-mirror</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/index.html#mirror">mirror</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/index.html#rss">rss</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">suricata</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="quick_start.html">快速使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="quick_start.html#id2">文件还原的简单实验</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quick_start.html#id3">安装部署</a></li>
<li class="toctree-l3"><a class="reference internal" href="quick_start.html#id4">配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="quick_start.html#id5">启动</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="">suricata4.0.1源码分析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">约定</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">概述及全局观览</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">全局变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#main">main</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#runmoderegisterrunmodes">RunModeRegisterRunModes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#globalsinitpreconfig">GlobalsInitPreConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="#postconfloadedsetup">PostConfLoadedSetup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#postconfloadeddetectsetup">PostConfLoadedDetectSetup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">参考文献</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">开源引擎借鉴</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="review.html">源码笔记(3.2.1)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="review.html#id2">调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#tcp">tcp识别总体流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#flow">flow模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#id3">TCP重组</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#id4">协议识别</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#id5">应用识别</a></li>
<li class="toctree-l3"><a class="reference internal" href="review.html#id6">协议解析</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../performance/index.html">performance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance/vtune.html">vtune使用教程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../performance/vtune.html#id1">安装部署</a></li>
<li class="toctree-l3"><a class="reference internal" href="../performance/vtune.html#id2">快速使用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cracker/index.html">逆向破解(协议分析方向)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cracker/OD.html">OD使用教程（偏向协议分析）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cracker/crackapp.html">加密协议逆向</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../cracker/crackapp.html#id2">加密数据破解工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#peid">查壳工具&#8211;Peid</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#id3">脱壳工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#id4">反汇编工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../cracker/crackapp.html#id5">加密数据解析步骤</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cracker/crackapp.html#id6">实例讲解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#id7">查壳</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#od">OD动态调试</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#ida">IDA静态分析 提取代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../cracker/crackapp.html#wireshark">wireshark插件编写(也可以自己写代码)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">陈令祥文档系统</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">suricata</a> &raquo;</li>
        
      <li>suricata4.0.1源码分析</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="suricata4-0-1">
<h1>suricata4.0.1源码分析<a class="headerlink" href="#suricata4-0-1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>约定<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul>
<li><p class="first">代码对应位置</p>
<div class="line-block">
<div class="line">在做review的时候，会在这个链接中写相关注释，尽量不在本文档中贴代码。</div>
<div class="line"><a class="reference external" href="https://github.com/promisechen/suricata/tree/master/suricata-4.0.1">https://github.com/promisechen/suricata/tree/master/suricata-4.0.1</a></div>
</div>
</li>
<li><p class="first">交流方式</p>
<div class="line-block">
<div class="line">可以通过微信promisechen或issue(推荐)进行沟通</div>
<div class="line">可在这里建立issue <a class="reference external" href="https://github.com/promisechen/suricata/issues">https://github.com/promisechen/suricata/issues</a></div>
</div>
</li>
<li><p class="first">假定按照这样进行配置编译</p>
<div class="line-block">
<div class="line">./configure &#8211;prefix=/usr &#8211;sysconfdir=/etc &#8211;localstatedir=/var &#8211;enable-nfqueue &#8211;enable-lua</div>
</div>
</li>
</ul>
<<<<<<< HEAD
<p>当前进度：开始分析PostConfLoadedDetectSetup-&gt;DetectEngineCtxInitReal-&gt;ActionInitConfig</p>
=======
<p>当前进度：开始分析PostConfLoadedSetup-&gt;MayDaemonize</p>
>>>>>>> 0b6744533e3fa724b7fd4af7b05fc93a27b97fb6
</div>
<div class="section" id="id2">
<h2>概述及全局观览<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>全局变量<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">定义</th>
<th class="head">说明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>host_mode</td>
<td>包括router和sniffer-only、auto三种模式，当使用auto模式时，在ips状态下设置为router,在ids下为sniffer-only</td>
</tr>
<tr class="row-odd"><td>alpd_ctx</td>
<td>协议识别的全局变量，存放了各种协议识别使用的数据：如字符串，状态机等</td>
</tr>
<tr class="row-even"><td>sigmatch_table</td>
<td>特征关键字匹配表，sid、priority、msg、within、distance等等。该变量主要应用于应用的识别和规则的检测。</td>
</tr>
<tr class="row-odd"><td>tmqh_table</td>
<td>提供了4种类型队列:simple,flow,packetpool,nfq,其中nfq不同于其他三种队列，他是内核中的Netfilter Queue。
simple是简单的先入先出的普通队列,packetpool</td>
</tr>
<tr class="row-even"><td>tmm_modules</td>
<td>线程模块的全局数组，有pcap/pfring/netmap等收包类线程，有flow管理类</td>
</tr>
</tbody>
</table>
<div class="section" id="alpd-ctx">
<h4>alpd_ctx介绍及内存布局<a class="headerlink" href="#alpd-ctx" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="sigmatch-table-todo">
<h4>sigmatch_table介绍(todo)<a class="headerlink" href="#sigmatch-table-todo" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="tmqh-tabletmqh">
<h4>tmqh_table对应的Tmqh结构体说明<a class="headerlink" href="#tmqh-tabletmqh" title="永久链接至标题">¶</a></h4>
<p>todo:tm_queuehandlers.h中</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span>enum {

    TMQH_SIMPLE,
    TMQH_NFQ,
    TMQH_PACKETPOOL,
    TMQH_FLOW,

    TMQH_SIZE,
};
typedef struct Tmqh_ {

    const char *name;
    Packet *(*InHandler)(ThreadVars *);           /*&lt; 是针对ThreadVars的输入，而非入队的意思，即从相应队列取出Packet。by clx 20171107 */
    void (*InShutdownHandler)(ThreadVars *);      /*&lt; 貌似是把队列中的报文都拿出来的意思??。by clx 20171107 */
    void (*OutHandler)(ThreadVars *, Packet *);   /*&lt; 将报文压入队列中。by clx 20171107*/
    void *(*OutHandlerCtxSetup)(const char *);    /*&lt; 初始化线程上下文。by clx 20171107*/
    void (*OutHandlerCtxFree)(void *);            /*&lt; 释放线程上下文。by clx 20171107*/
    void (*RegisterTests)(void);
} Tmqh;
Tmqh tmqh_table[TMQH_SIZE];
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="main">
<h2>main<a class="headerlink" href="#main" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>主线</li>
</ol>
<p class="graphviz">
<img src="../_images/graphviz-6e409c530e011c8423db8215ebdc915f3c9ab6ec.png" alt="digraph G {
             SCInstanceInit:初始化实例
             -&gt;SC_ATOMIC_INIT
             -&gt;SCLogInitLogModule_创建日志子系统实例
             -&gt;SCSetThreadName_设置线程名称
             -&gt;ParseSizeInit_应该是解析用的_后续研究
             -&gt;RunModeRegisterRunModes
             -&gt;ConfInit_创建一个root节点_存储配置信息
             -&gt;ParseCommandLine_解析命令信息_存放到SCInstance结构suri局部变量中
             -&gt;FinalizeRunMode_检查和设定运行模式
             -&gt;StartInternalRunMode_处理内部模式，比如查看当前支持的协议列表、支持的模式等
             -&gt;GlobalsInitPreConfig_初始化全局配置_如队列、快速匹配链表等
             -&gt;LoadYamlConfig_读取yaml格式配置文件
             -&gt;PostConfLoadedSetup

             }

SCInstanceInit(初始化实例)-&gt;SC_ATOMIC_INIT-&gt;SCLogInitLogModule(创建日志子系统实例)-&gt;SCSetThreadName（设置线程名称）-&gt; ParseSizeInit(应该是解析用的，后续研究)-&gt;RunModeRegisterRunModes
-&gt;ConfInit(创建一个root节点,存储配置信息)-&gt;ParseCommandLine(解析命令信息，存放到SCInstance suri局部变量中)-&gt;FinalizeRunMode(检查和设定运行模式)-&gt;StartInternalRunMode(处理内部模式，比如查看当前支持的协议列表、支持的模式等)
-&gt;GlobalsInitPreConfig(1.2 初始化全局配置 如队列、快速匹配链表等)－&gt;LoadYamlConfig(1.3  读取yaml格式配置文件)
-&gt;PostConfLoadedSetup" />
</p>
<div class="section" id="runmoderegisterrunmodes">
<h3>RunModeRegisterRunModes<a class="headerlink" href="#runmoderegisterrunmodes" title="永久链接至标题">¶</a></h3>
<blockquote>
<div>调用RunModeIdsXXXXRegister将各种模式注册好(todo:以pcap的模式作为模板进行研究)
他们都调用RunModeRegisterNewRunMode紧张注册，</div></blockquote>
</div>
<div class="section" id="globalsinitpreconfig">
<h3>GlobalsInitPreConfig<a class="headerlink" href="#globalsinitpreconfig" title="永久链接至标题">¶</a></h3>
<blockquote>
<div>初始化trans_q 和data_queues（todo:深入分析两个变量） CreateLowercaseTable（字母转换数组初始化）
TimeInit SupportFastPatternForSigMatchTypes三个函数逐个调用。
SupportFastPatternForSigMatchTypes将DETECT_SM_LIST_PMATCH加入sm_fp_support_smlist_list链表，优先级是3</div></blockquote>
<p>1.3 todo:</p>
</div>
<div class="section" id="postconfloadedsetup">
<h3>PostConfLoadedSetup<a class="headerlink" href="#postconfloadedsetup" title="永久链接至标题">¶</a></h3>
<p class="graphviz">
<img src="../_images/graphviz-c88f8a58ad8763fda960ee13993e3e3703fdd280.png" alt="digraph G {
        size=&quot;1024,1024&quot;;
        label=&quot;PostConfLoadedSetup处理流程&quot;

        PostConfLoadedSetup  [label=&quot;PostConfLoadedSetup&quot;] ;
        MpmTableSetup [label=&quot;MpmTableSetup&quot;] ;
        SpmTableSetup [label=&quot;SpmTableSetup&quot;] ;
        AppLayerSetup [label=&quot;AppLayerSetup&quot;] ;
        AppLayerProtoDetectSetup [label=&quot;AppLayerProtoDetectSetup&quot;] ;
        AppLayerParserSetup [label=&quot;AppLayerParserSetup&quot;] ;
        AppLayerParserRegisterProtocolParsers [label=&quot;AppLayerParserRegisterProtocolParsers \n注册协议识别字符串特征或端口特征；注册协议解析函数回调&quot;] ;
        RegisterHTPParsers [label=&quot;RegisterHTPParsers \nhttp协议识别和解析初始化&quot;] ;
        AppLayerProtoDetectConfProtoDetectionEnabled [label=&quot;AppLayerProtoDetectConfProtoDetectionEnabled&quot;] ;
        AppLayerProtoDetectRegisterProtocol [label=&quot;AppLayerProtoDetectRegisterProtocol&quot;] ;
        HTPRegisterPatternsForProtocolDetection [label=&quot;HTPRegisterPatternsForProtocolDetection\n将字符串、端口特征添加到状态机&quot;] ;
        AppLayerParserRegisterXXXXX [label=&quot;HTPRegisterPatternsForProtocolDetection\n添加解析相关函数集&quot;] ;
        RegisterSSLParsers [label=&quot;RegisterSSLParsers&quot;] ;
        RegisterFTPParsers [label=&quot;RegisterFTPParsers&quot;] ;
        AppLayerProtoDetectPrepareState [label=&quot;AppLayerProtoDetectPrepareState&quot;] ;
        SCHInfoLoadFromConfig [label=&quot;SCHInfoLoadFromConfig&quot;] ;
        AppLayerProtoDetectPMMapSignatures [label=&quot;AppLayerProtoDetectPMMapSignatures &quot;] ;
        AppLayerProtoDetectPMPrepareMpm [label=&quot;AppLayerProtoDetectPrepareState&quot;] ;
        SigTableSetup [label=&quot;SigTableSetup\n注册关键字回调函数 &quot;] ;
        DetectSidRegister [label=&quot;DetectSidRegister&quot;] ;
        DetectContentRegister [label=&quot;DetectContentRegister&quot;] ;
        DetectUricontentRegister [label=&quot;DetectUricontentRegister&quot;] ;
        DetectBufferTypeFinalizeRegistration [label=&quot;DetectBufferTypeFinalizeRegistration&quot;] ;
        TmqhSetup [label=&quot;TmqhSetup\n注册队列接口&quot;] ;
        TmqhSimpleRegister [label=&quot;TmqhSimpleRegister\n普通队列&quot;] ;
        TmqhNfqRegister [label=&quot;TmqhNfqRegister\n内核Netfilter 队列&quot;] ;
        TmqhPacketpoolRegister [label=&quot;TmqhPacketpoolRegister\n类似mbuf&quot;] ;
        TmqhFlowRegister [label=&quot;TmqhFlowRegister\n根据五元组hash的队列&quot;]
        SigParsePrepare [label=&quot;SigParsePrepare\n初始化sig解析正则库&quot;]
        SCProtoNameInit [label=&quot;SCProtoNameInit\n从/etc/protocols获取协议名称&quot;]
        xxxTagInit [label=&quot;TagInitCtx/PacketAlertTagInit/ThresholdInit\nHostBitInitCtx/IPPairBitInitCtx&quot;]
        RegisterAllModules [label=&quot;RegisterAllModules\n注册各线程模块回调&quot;]
        TmModuleFlowManagerRegister [label=&quot;TmModuleFlowManagerRegister\n流表管理&quot;]
        TmModuleReceiveAFPRegister [label=&quot;TmModuleReceiveAFPRegister\nafp接收线程&quot;]
        TmModuleDecodeAFPRegister [label=&quot;TmModuleDecodeAFPRegister\nafp解码线程&quot;]
        AppLayerHtpNeedFileInspection [label=&quot;AppLayerHtpNeedFileInspection\n设置htp库部分配置&quot;]
        StorageFinalize [label=&quot;StorageFinalize\n初始化storage_map&quot;]
        TmModuleRunInit [label=&quot;TmModuleRunInit\n调用tm的init&quot;]
        HostInitConfig [label=&quot;HostInitConfig\n主机内存初始化&quot;]

        PreRunInit [label=&quot;PreRunInit\n流表，ip分片重组，tcp分片重组分配内存并进行初始化&quot;]
        DefragInit [label=&quot;DefragInit\nIP分片内存初始化&quot;]
        FlowInitConfig [label=&quot;FlowInitConfig\nFLOW内存初始化&quot;]
        IPPairInitConfig [label=&quot;IPPairInitConfig\nIP声望内存初始化&quot;]
        StreamTcpInitConfig [label=&quot;StreamTcpInitConfig\n流重组内存初始化&quot;]

        dengdeng [label=&quot;......&quot;] ;
        RegisterXXXParsers [label=&quot;......&quot;] ;
        DetectXXXXRegister [label=&quot;......&quot;] ;
        TmModuleReceiveXXXRegister [label=&quot;......&quot;] ;
        PostConfLoadedSetup-&gt;SpmTableSetup
        PostConfLoadedSetup-&gt;MpmTableSetup
        PostConfLoadedSetup-&gt;AppLayerSetup
            AppLayerSetup-&gt;AppLayerParserSetup
            AppLayerSetup-&gt;AppLayerProtoDetectSetup
            AppLayerSetup-&gt;AppLayerParserRegisterProtocolParsers
                AppLayerParserRegisterProtocolParsers-&gt;RegisterHTPParsers
                    RegisterHTPParsers-&gt;AppLayerProtoDetectConfProtoDetectionEnabled
                    RegisterHTPParsers-&gt;AppLayerProtoDetectRegisterProtocol
                    RegisterHTPParsers-&gt;HTPRegisterPatternsForProtocolDetection
                    RegisterHTPParsers-&gt;AppLayerParserRegisterXXXXX
                AppLayerParserRegisterProtocolParsers-&gt;RegisterFTPParsers
                AppLayerParserRegisterProtocolParsers-&gt;RegisterXXXParsers
                AppLayerParserRegisterProtocolParsers-&gt;RegisterSSLParsers
        PostConfLoadedSetup-&gt;AppLayerProtoDetectPrepareState
            AppLayerProtoDetectPrepareState-&gt;AppLayerProtoDetectPMMapSignatures
            AppLayerProtoDetectPrepareState-&gt;AppLayerProtoDetectPMPrepareMpm
        PostConfLoadedSetup-&gt;SCHInfoLoadFromConfig
        PostConfLoadedSetup-&gt;SigTableSetup
            SigTableSetup-&gt;DetectSidRegister
            SigTableSetup-&gt;DetectContentRegister
            SigTableSetup-&gt;DetectXXXXRegister
            SigTableSetup-&gt;DetectUricontentRegister
            SigTableSetup-&gt;DetectBufferTypeFinalizeRegistration
        PostConfLoadedSetup-&gt;TmqhSetup
            TmqhSetup-&gt;TmqhSimpleRegister
            TmqhSetup-&gt;TmqhNfqRegister
            TmqhSetup-&gt;TmqhPacketpoolRegister
            TmqhSetup-&gt;TmqhFlowRegister
        PostConfLoadedSetup-&gt;SigParsePrepare
        PostConfLoadedSetup-&gt;SCProtoNameInit

        PostConfLoadedSetup-&gt;xxxTagInit
        PostConfLoadedSetup-&gt;RegisterAllModules
            RegisterAllModules-&gt;TmModuleFlowManagerRegister
            RegisterAllModules-&gt;TmModuleReceiveXXXRegister
            RegisterAllModules-&gt;TmModuleReceiveAFPRegister
            RegisterAllModules-&gt;TmModuleDecodeAFPRegister
        PostConfLoadedSetup-&gt;AppLayerHtpNeedFileInspection
        PostConfLoadedSetup-&gt;StorageFinalize
        PostConfLoadedSetup-&gt;TmModuleRunInit

        PostConfLoadedSetup-&gt;HostInitConfig
        PostConfLoadedSetup-&gt;PreRunInit
            PreRunInit-&gt;DefragInit
            PreRunInit-&gt;FlowInitConfig
            PreRunInit-&gt;IPPairInitConfig
            PreRunInit-&gt;StreamTcpInitConfig
}

MpmTableSetup(注册多模式匹配算法)-&gt;SpmTableSetup(注册单模式匹配算法)-&gt;网卡offloading、checksum等配置读取-&gt;AppLayerSetup" />
</p>
<ul class="simple">
<li>MpmTableSetup</li>
</ul>
<p>注册各种多模匹配算法，将ac ac-cuda ac_bs ac_tile hyperscan 这几种多模式匹配算法，注册到mpm_table(结构为MpmTableElmt)</p>
<p>全局变量中 mpm_default_matcher作为默认配置</p>
<ul class="simple">
<li>SpmTableSetup</li>
</ul>
<p>注册各种单模匹配算法，将bm hyperscan这两种单模式匹配算法，注册到spm_table(结构为SpmTableElmt)的全局变量中</p>
<ul>
<li><p class="first">AppLayerSetup</p>
</li>
<li><p class="first">AppLayerProtoDetectSetup</p>
<blockquote>
<div><p>主要是对alpd_ctxl4层协议(tcp,udp,icmp,sctp)层面的多模和单模的注册和初始化，
主要是给alpd_ctx.spm_global_thread_ctx和MpmInitCtx调用进行赋值(todo:多模匹配算法插件接口)</p>
<p>alpd_ctx是协议识别的全局变量，存放了各种协议识别使用的数据：如字符串，状态机等</p>
</div></blockquote>
</li>
<li><p class="first">AppLayerParserSetup</p>
</li>
<li><p class="first">AppLayerParserRegisterProtocolParsers</p>
<blockquote>
<div><p>注册协议识别字符串特征或端口特征；注册协议解析函数回调</p>
<ul>
<li><p class="first">RegisterHTPParsers</p>
<blockquote>
<div><p>http协议识别字符串注册，解析函数注册</p>
<ul>
<li><p class="first">AppLayerProtoDetectConfProtoDetectionEnabled(判断该协议是否启动)</p>
</li>
<li><p class="first">AppLayerProtoDetectRegisterProtocol(注册http协议识别)</p>
</li>
<li><p class="first">HTPRegisterPatternsForProtocolDetection:(将该协议识别的特征串放入alpd_ctx相应的状态机中)</p>
<p>这里将调用AppLayerProtoDetectPMRegisterPatternCI/CS注册字符串特征，
如果有端口特征则通过AppLayerProtoDetectPPRegister注册（如RegisterDNSUDPParsers）,该函数有2个参数ProbingParserFPtr，
当命中端口后，还会运行该函数做进一步判断。</p>
</li>
<li><p class="first">AppLayerParserRegisterXXXXX(该系列函数是注册协议解析的相关插件,todo:研究解析过程)</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">AppLayerProtoDetectPrepareState</p>
<blockquote>
<div><p>(todo:详细分析协议维度字符串添加过程、内存布局)：添加特征到状态机并编译</p>
<ul class="simple">
<li>AppLayerProtoDetectPMMapSignatures :添加到状态机</li>
<li>AppLayerProtoDetectPMPrepareMpm :编译</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">SCHInfoLoadFromConfig</p>
<blockquote>
<div><p>将配置文件中的host-os-policy的配置加入到一棵radix树上，在匹配是使用。(todo:识别或重组时使用？？)</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>SigTableSetup</dt>
<dd><p class="first">注册关键字的各种回调,比如注册sid,content等相关回调，在读取加载规则库、应用识别的时候将调用相关回调函数.
目前看到这些函数应该是被SigInit调用.这里注册的关键非常的多，可以慢慢分析自己感兴趣的,其中发现很多关键字没有注册
Match这个回调。http相关的注册项有很多,http的一些注册还会初始化一些资源,后面以DetectHttpUriRegister为例。</p>
<ul class="last">
<li><dl class="first docutils">
<dt>DetectSidRegister</dt>
<dd><p class="first">注册了重要的函数DetectSidSetup，该函数将在加载规则库的时候，被调用。</p>
<p>DetectSidSetup将会把规则库中的sidstr赋给s-&gt;id</p>
<blockquote class="last">
<div><div class="highlight-python"><div class="highlight"><pre><span></span>static int DetectSidSetup (DetectEngineCtx *de_ctx, Signature *s, const char *sidstr)
{

    unsigned long id = 0;
    char *endptr = NULL;
    id = strtoul(sidstr, &amp;endptr, 10);
    if (endptr == NULL || *endptr != &#39;\0&#39;) {

    SCLogError(SC_ERR_INVALID_SIGNATURE, &quot;invalid character as arg &quot;
    &quot;to sid keyword&quot;);
    goto error;
    }
    if (id &gt;= UINT_MAX) {

    SCLogError(SC_ERR_INVALID_NUMERIC_VALUE, &quot;sid value to high, max %u&quot;, UINT_MAX);
    goto error;
    }
    if (id == 0) {

    SCLogError(SC_ERR_INVALID_NUMERIC_VALUE, &quot;sid value 0 is invalid&quot;);
    goto error;
    }
    if (s-&gt;id &gt; 0) {

    SCLogError(SC_ERR_INVALID_RULE_ARGUMENT, &quot;duplicated &#39;sid&#39; keyword detected&quot;);
    goto error;
    }

    s-&gt;id = (uint32_t)id;
    return 0;

    error:
    return -1;
}
</pre></div>
</div>
</div></blockquote>
</dd>
</dl>
</li>
<li><p class="first">DetectPriorityRegister</p>
<p>注册了重要的函数DetectPrioritySetup，该函数将在加载规则库的时候，被调用。
DetectPrioritySetup将把规则库中的rawstr赋值给s-&gt;prio,但是相对DetectSidSetup多了一些pcre_exec、pcre_copy_substring相关函数调用,做什么用的呢？？
他们主要是判断关键字是否合法，并提取相关字段，注意regex、regex_study是static类型的,这2个全局变量在很多文件中都存在。</p>
</li>
<li><p class="first">DetectHttpUriRegister
也注册了Setup回调。注册回调之后，重点注册了DetectAppLayerMpmRegister和DetectAppLayerInspectEngineRegister(todo:检查相关注册)</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">TmqhSetup</p>
<blockquote>
<div><blockquote>
<div><p>注册4中类型队列，后续各线程交互时使用</p>
</div></blockquote>
<ul>
<li><p class="first">TmqhSimpleRegister</p>
<blockquote>
<div><p>简单的普通的入队出队队列，主要注册了TmqhInputSimple和TmqhOutputSimple，TmqhInputSimple
输入回调，即从相应队列中获取报文，这里的input是针对ThreadVars来说的。</p>
</div></blockquote>
</li>
<li><p class="first">TmqhNfqRegister</p>
<blockquote>
<div><p>内核层面的队列，即 Netfilter Queue队列，与其他三种队列不同，他只需要注册OutHandler</p>
</div></blockquote>
</li>
<li><p class="first">TmqhPacketpoolRegister</p>
<blockquote>
<div><p>这个更像是一个dpdk中的mbuf，内核中的skb_mbuf之类的ringbuffer. 这个其实更像说是内存池，这种队列应该是用在
收包这一层层面。</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>TmqhFlowRegister</dt>
<dd><blockquote class="first">
<div><p>根据flow进行分发的队列,出队列与Simple是一样的，入队会根据flow的hash进行除余得到相应的队列。
根据配置的不同，将选择不同的分发算法:TmqhOutputFlowHash TmqhOutputFlowIPPair</p>
</div></blockquote>
<p>TmqhOutputFlowIPPair的部分代码</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span>void TmqhOutputFlowIPPair(ThreadVars *tv, Packet *p)
{

    int16_t qid = 0;
    uint32_t addr_hash = 0;
    int i;

    TmqhFlowCtx *ctx = (TmqhFlowCtx *)tv-&gt;outctx;

    if (p-&gt;src.family == AF_INET6) {

    for (i = 0; i &lt; 4; i++) {

        addr_hash += p-&gt;src.addr_data32[i] + p-&gt;dst.addr_data32[i];
    }
    } else {

        addr_hash = p-&gt;src.addr_data32[0] + p-&gt;dst.addr_data32[0];
    }

    /* we don&#39;t have to worry about possible overflow, since
    * ctx-&gt;size will be lesser than 2 ** 31 for sure */
      qid = addr_hash % ctx-&gt;size;

    PacketQueue *q = ctx-&gt;queues[qid].q;
    SCMutexLock(&amp;q-&gt;mutex_q);
    PacketEnqueue(q, p);
    SCCondSignal(&amp;q-&gt;cond_q);
    SCMutexUnlock(&amp;q-&gt;mutex_q);

    return;
}
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">SigParsePrepare</p>
<blockquote>
<div><dl class="docutils">
<dt>初始化config_pcre、config_pcre_extra、option_pcre三个全局变量，后面解析使用</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span>opts |= PCRE_UNGREEDY;
config_pcre = pcre_compile(regexstr, opts, &amp;eb, &amp;eo, NULL);
if(config_pcre == NULL)
{

    SCLogError(SC_ERR_PCRE_COMPILE, &quot;pcre compile of \&quot;%s\&quot; failed at offset %&quot; PRId32 &quot;: %s&quot;, regexstr, eo, eb);
    exit(1);
}

config_pcre_extra = pcre_study(config_pcre, 0, &amp;eb);
if(eb != NULL)
{

    SCLogError(SC_ERR_PCRE_STUDY, &quot;pcre study failed: %s&quot;, eb);
    exit(1);
}

regexstr = OPTION_PCRE;
opts |= PCRE_UNGREEDY;

option_pcre = pcre_compile(regexstr, opts, &amp;eb, &amp;eo, NULL);
if(option_pcre == NULL)
{

    SCLogError(SC_ERR_PCRE_COMPILE, &quot;pcre compile of \&quot;%s\&quot; failed at offset %&quot; PRId32 &quot;: %s&quot;, regexstr, eo, eb);
    exit(1);
}
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>xxxTagInit</dt>
<dd><p class="first last">存储结构的初始化，有三种存储方式STORAGE_HOSTSTORAGE_FLOWSTORAGE_IPPAIR分别用于不同类型的存储。
这里共初始化了host_tag_id、flow_tag_id、threshold_id、host_bit_id、ippair_bit_id5个储存实体对象。
应该与与规则中的tag、threshould关键字的实现相关;</p>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span></span>static StorageList *storage_list = NULL; /**&lt; by clx 20171109 储存链表*/
static int storage_max_id[STORAGE_MAX];  /**&lt; by clx 20171109 三种储存方式的id编号*/
static int storage_registraton_closed = 0; /**&lt; by clx 20171109 关闭标记，当设置为1时，不在注册*/
static StorageMapping **storage_map = NULL;/**&lt; by clx 20171109 将储存链表上所有storage实体做映射成二维数组，
通过储存类型和在该类型的储存方式对应的id进行读取。如storage_map[STORAGE_HOST][host_tag_id]读取host_tag_id的存储注册函数*/
</pre></div>
</div>
</li>
<li><dl class="first docutils">
<dt>DetectAddressTestConfVars、DetectPortTestConfVars</dt>
<dd><p class="first last">检查配置文件中vars.address-groups和vars.port-groups的合法性。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>RegisterAllModules</dt>
<dd><p class="first last">注册线程模式:流表管理相关、报文接收方式(pcap/pfring/netmap等)
线程类型共下面几类:其中文接收方式使用的是RECEIVE_TM和DECODE_TM，
其中五元组表有MANAGEMENT_TM|TM_FLAG_STREAM_TM|TM_FLAG_DETECT_TM三个专用类型,以af-packet为例</p>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1">#define TM_FLAG_RECEIVE_TM      0x01</span>
<span class="c1">#define TM_FLAG_DECODE_TM       0x02</span>
<span class="c1">#define TM_FLAG_STREAM_TM       0x04</span>
<span class="c1">#define TM_FLAG_DETECT_TM       0x08</span>
<span class="c1">#define TM_FLAG_LOGAPI_TM       0x10 /**&lt; TM is run by Log API */</span>
<span class="c1">#define TM_FLAG_MANAGEMENT_TM   0x20</span>
<span class="c1">#define TM_FLAG_COMMAND_TM      0x40</span>
</pre></div>
</div>
<dl class="docutils">
<dt>以af-packet为例:TmModuleDecodeAFPRegister和TmModuleReceiveAFPRegister分别定义了收包和解码的回调。</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span>void TmModuleReceiveAFPRegister (void)
{
    tmm_modules[TMM_RECEIVEAFP].name = &quot;ReceiveAFP&quot;;
    tmm_modules[TMM_RECEIVEAFP].ThreadInit = NoAFPSupportExit;
    tmm_modules[TMM_RECEIVEAFP].Func = NULL;
    tmm_modules[TMM_RECEIVEAFP].ThreadExitPrintStats = NULL;
    tmm_modules[TMM_RECEIVEAFP].ThreadDeinit = NULL;
    tmm_modules[TMM_RECEIVEAFP].RegisterTests = NULL;
    tmm_modules[TMM_RECEIVEAFP].cap_flags = 0;
    tmm_modules[TMM_RECEIVEAFP].flags = TM_FLAG_RECEIVE_TM;
}

/**
* \brief Registration Function for DecodeAFP.
* \todo Unit tests are needed for this module.
*/
void TmModuleDecodeAFPRegister (void)
{
    tmm_modules[TMM_DECODEAFP].name = &quot;DecodeAFP&quot;;
    tmm_modules[TMM_DECODEAFP].ThreadInit = NoAFPSupportExit;
    tmm_modules[TMM_DECODEAFP].Func = NULL;
    tmm_modules[TMM_DECODEAFP].ThreadExitPrintStats = NULL;
    tmm_modules[TMM_DECODEAFP].ThreadDeinit = NULL;
    tmm_modules[TMM_DECODEAFP].RegisterTests = NULL;
    tmm_modules[TMM_DECODEAFP].cap_flags = 0;
    tmm_modules[TMM_DECODEAFP].flags = TM_FLAG_DECODE_TM;
}
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p class="first">AppLayerHtpNeedFileInspection</p>
<blockquote>
<div><p>为htp库设置一些标记，如解析响应、解析请求的标记</p>
</div></blockquote>
</li>
<li><p class="first">StorageFinalize</p>
<blockquote>
<div><p>将xxxTagInit注册的实体，将储存链表上所有storage实体做映射成二维数组，
通过储存类型和在该类型的储存方式对应的id进行读取。如storage_map[STORAGE_HOST][host_tag_id]读取host_tag_id的存储注册函数</p>
</div></blockquote>
</li>
<li><p class="first">TmModuleRunInit</p>
<blockquote>
<div><p>调用tmm_modules[i]-&gt;Init进行模块初始化</p>
</div></blockquote>
</li>
<li><p class="first">MayDaemonize</p>
<blockquote>
<div><div class="line-block">
<div class="line">后台运行,检查是否进入Daemon模式。若需要进入Daemon模式，则会检测pidfile是</div>
<div class="line">否已经存在（daemon下只能有一个实例运行），然后进行Daemonize，最后创建一个</div>
<div class="line">pidfile。Daemonize的主要思路是：fork-&gt;子进程调用setsid创建一个新的session</div>
<div class="line">，关闭stdin、stdout、stderr，并告诉父进程 –&gt; 父进程等待子进程通知，然后退</div>
<div class="line">出 –&gt; 子进程继续执行.</div>
</div>
</div></blockquote>
</li>
<li><p class="first">InitSignalHandler</p>
<blockquote>
<div><div class="line-block">
<div class="line">注册各种信号,初始化信号handler。首先为SIGINT（ctrl-c触发）和SIGTERM（不带</div>
<div class="line">参数kill时触发）这两个常规退出信号分别注册handler，对SIGINT的处理是设置程</div>
<div class="line">序的状态标志为STOP，即让程序优雅地退出；而对SIGTERM是设置为KILL，即强杀。</div>
<div class="line">接着，程序会忽略SIGPIPE（这个信号通常是在Socket通信时向已关闭的连接另一端</div>
<div class="line">发送数据时收到）和SIGSYS（当进程尝试执行一个不存在的系统调用时收到）信号，</div>
<div class="line">以加强程序的容错性和健壮性。</div>
</div>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>HostInitConfig</dt>
<dd><p class="first last">与FlowInitConfig类似: host_hash,host_config</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>SCAsn1LoadConfig</dt>
<dd><p class="first last">读取asn1-max-frames设置到全局变量asn1_max_frames_config</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CoredumpLoadConfig</dt>
<dd><p class="first last">coredump设置</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>DecodeGlobalConfig</dt>
<dd><p class="first last">设置是否解析g_teredo_enabled</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>PreRunInit</dt>
<dd><dl class="first last docutils">
<dt>为流表，ip分片重组，tcp分片重组分配内存并进行初始化</dt>
<dd><ul class="first last">
<li><p class="first">StatsInit 统计初始化</p>
</li>
<li><p class="first">DefragInit 分片重组,暂不关心</p>
</li>
<li><dl class="first docutils">
<dt>FlowInitConfig</dt>
<dd><p class="first">初始化flow的配置，flow_config是flow的全局配置,flow_hash是hash表,flow_spare_q flow节点
的队列，调用FlowAlloc分配内存之后，将把分配的flow放到flow_spare_q队列中。</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span>/* global flow config */
typedef struct FlowCnf_
{

  uint32_t hash_rand;
  uint32_t hash_size;  /**&lt;by clx 20171110 hash筒的大小*/
  uint64_t memcap;     /**&lt;by clx 20171110 flows最大占的内存限制*/
  uint32_t max_flows;
  uint32_t prealloc;   /**&lt;by clx 20171110 最大并发数*/

  uint32_t timeout_new;
  uint32_t timeout_est;

  uint32_t emerg_timeout_new;
  uint32_t emerg_timeout_est;
  uint32_t emergency_recovery;

} FlowConfig;
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>IPPairInitConfig</dt>
<dd><p class="first last">类似FlowInitConfig初始化ip的相关内存</p>
</dd>
</dl>
</li>
<li><p class="first">LogFilestoreInitConfig 文件存储的配置</p>
</li>
<li><p class="first">StreamTcpInitConfig 流重组的初始化,todo:暂不看tcp流重组的细节</p>
</li>
<li><p class="first">AppLayerParserPostStreamSetup todo:暂不看tcp流重组的细节</p>
</li>
<li><p class="first">AppLayerRegisterGlobalCounters todo:设置一些计数配置，后面研究下咋用的。</p>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<<<<<<< HEAD
</ul>
</div>
<div class="section" id="postconfloadeddetectsetup">
<h3>PostConfLoadedDetectSetup<a class="headerlink" href="#postconfloadeddetectsetup" title="永久链接至标题">¶</a></h3>
<ul>
<li><dl class="first docutils">
<dt>SCClassConfInit  解析classification.config配置文件相关；为解析classification.config</dt>
<dd><dl class="first last docutils">
<dt>，注册正则匹配handle和相关正则。</dt>
<dd><p class="first">从classification.config摘抄，下面的第一个规则指定了类型为attempted-admin，但是
他又重新设定了优先级为10，所以他最终优先级为10.而第二个规则只指定了attempted-admin，那么他就
使用默认优先级1.</p>
<blockquote class="last">
<div><div class="highlight-python"><div class="highlight"><pre><span></span>#
# config classification:shortname,short description,priority
#
config classification: attempted-admin,Attempted Administrator Privilege Gain,1

# Here are a few example rules:
#
#   alert TCP any any -&gt; any 80 (msg: &quot;EXPLOIT ntpdx overflow&quot;;
#       dsize: &gt; 128; classtype:attempted-admin; priority:10;
#
#   alert TCP any any -&gt; any 25 (msg:&quot;SMTP expn root&quot;; flags:A+; \
#             content:&quot;expn root&quot;; nocase; classtype:attempted-recon;)
#
# The first rule will set its type to &quot;attempted-admin&quot; and override
# the default priority for that type to 10.
#
# The second rule set its type to &quot;attempted-recon&quot; and set its
# priority to the default for that type.
#
</pre></div>
</div>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>SCReferenceConfInit();</dt>
<dd><p class="first">解析reference.config配置文件相关；为解析reference.config，注册则匹配handle和相关正则。
对应的cveexploitdb等相关连接</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span># config reference: system URL
config reference: bugtraq   http://www.securityfocus.com/bid/
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>SetupDelayedDetect</dt>
<dd><p class="first last">读取detect.delayed-detect的配置，detect.delayed-detect表示在加载规则库之前就启动
抓包,这样能够在IPS模式下减少系统的down time（宕机时间)，但注意载离线模式下，将忽略改标记。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>DetectEngineMultiTenantSetup</dt>
<dd><p class="first last">目前给我的感觉是多级的检测,后面在看吧。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>DetectEngineCtxInit/DetectEngineCtxInitMinimal</dt>
<dd><blockquote class="first">
<div><p>初始化检测引擎上下文。</p>
</div></blockquote>
<ul class="last">
<li><p class="first">DetectEngineCtxLoadConf 加载配置</p>
</li>
<li><p class="first">创建各种hash表</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>SigGroupHeadHashInit(de_ctx);
MpmStoreInit(de_ctx);
ThresholdHashInit(de_ctx);
DetectParseDupSigHashInit(de_ctx);
DetectAddressMapInit(de_ctx);
(void)SRepInit(de_ctx);
</pre></div>
</div>
</li>
<li><p class="first">SCClassConfLoadClassficationConfigFile
&nbsp; &nbsp;读取classfication的配置,并完成初始化</p>
<ul>
<li><dl class="first docutils">
<dt>SCClassConfInitContextAndLocalResources</dt>
<dd><p class="first last">注册hashtable de_ctx-&gt;class_conf_ht初始化以及fd文件描述符</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>SCClassConfParseFile</dt>
<dd><p class="first">读取解析并加入de_ctx-&gt;class_conf_ht hash表中</p>
<blockquote class="last">
<div><ul>
<li><dl class="first docutils">
<dt>SCClassConfIsLineBlankOrComment</dt>
<dd><p class="first last">过滤掉空行和注释行。</p>
</dd>
</dl>
</li>
<li><p class="first">SCClassConfAddClasstype</p>
<blockquote>
<div><p>解析一行并将相关字符  付给 SCClassConfClasstype 结构，而后将
其加到de_ctx-&gt;class_conf_ht 　hash表中，至此classification.config的
文件解析相关完毕。</p>
<p>对classification.config的做个简单的总结:
在PostConfLoadedDetectSetup－－》SCClassConfInit中注册了相关正则匹配对象regex，在SCClassConfInitContextAndLocalResources
中注册了de_ctx-&gt;class_conf_ht hash表，最后在SCClassConfAddClasstype将classification.config的相关
配置都加载到de_ctx-&gt;class_conf_ht hash表中。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>/**
 * \brief Parses a line from the classification file and adds it to Classtype
 *        hash table in DetectEngineCtx, i.e. DetectEngineCtx-&gt;class_conf_ht.
 *
 * \param rawstr Pointer to the string to be parsed.
 * \param index  Relative index of the string to be parsed.
 * \param de_ctx Pointer to the Detection Engine Context.
 *
 * \retval  0 On success.
 * \retval -1 On failure.
 */
static int SCClassConfAddClasstype(char *rawstr, uint8_t index, DetectEngineCtx *de_ctx)
{

    char ct_name[64];
    char ct_desc[512];
    char ct_priority_str[16];
    int ct_priority = 0;
    uint8_t ct_id = index;

    SCClassConfClasstype *ct_new = NULL;
    SCClassConfClasstype *ct_lookup = NULL;

#define MAX_SUBSTRINGS 30
    int ret = 0;
    int ov[MAX_SUBSTRINGS];
      //by clx 20171113 之前注册了相关正则，这里进行正则的匹配，并将
      //名称，描述，优先级解析出来。
    ret = pcre_exec(regex, regex_study, rawstr, strlen(rawstr), 0, 0, ov, 30);
    if (ret &lt; 0) {

        SCLogError(SC_ERR_INVALID_SIGNATURE, &quot;Invalid Classtype in &quot;
                &quot;classification.config file&quot;);
        goto error;
    }

    /* retrieve the classtype name */
    ret = pcre_copy_substring((char *)rawstr, ov, 30, 1, ct_name, sizeof(ct_name));
    if (ret &lt; 0) {

        SCLogInfo(&quot;pcre_copy_substring() failed&quot;);
        goto error;
    }

    /* retrieve the classtype description */
    ret = pcre_copy_substring((char *)rawstr, ov, 30, 2, ct_desc, sizeof(ct_desc));
    if (ret &lt; 0) {

        SCLogInfo(&quot;pcre_copy_substring() failed&quot;);
        goto error;
    }

    /* retrieve the classtype priority */
    ret = pcre_copy_substring((char *)rawstr, ov, 30, 3, ct_priority_str, sizeof(ct_priority_str));
    if (ret &lt; 0) {

        SCLogInfo(&quot;pcre_copy_substring() failed&quot;);
        goto error;
    }
    if (strlen(ct_priority_str) == 0) {

        goto error;
    }

    ct_priority = atoi(ct_priority_str);
      // by clx 20171113 创建一个对象，并将其加入hash表中。
    /* Create a new instance of the parsed Classtype string */
    ct_new = SCClassConfAllocClasstype(ct_id, ct_name, ct_desc, ct_priority);
    if (ct_new == NULL)
        goto error;

    /* Check if the Classtype is present in the HashTable.  In case it&#39;s present
     * ignore it, as it is a duplicate.  If not present, add it to the table */
    ct_lookup = HashTableLookup(de_ctx-&gt;class_conf_ht, ct_new, 0);
    if (ct_lookup == NULL) {

        if (HashTableAdd(de_ctx-&gt;class_conf_ht, ct_new, 0) &lt; 0)
            SCLogDebug(&quot;HashTable Add failed&quot;);
    } else {

        SCLogDebug(&quot;Duplicate classtype found inside classification.config&quot;);
        if (ct_new-&gt;classtype_desc) SCFree(ct_new-&gt;classtype_desc);
        if (ct_new-&gt;classtype) SCFree(ct_new-&gt;classtype);
        SCFree(ct_new);
    }

    return 0;

error:
    return -1;
}
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</li>
<li><p class="first">SCRConfLoadReferenceConfigFile
&nbsp; &nbsp;与classfication类似</p>
</li>
</ul>
</dd>
</dl>
</li>
=======
>>>>>>> 0b6744533e3fa724b7fd4af7b05fc93a27b97fb6
</ul>
</div>
</div>
<div class="section" id="id4">
<h2>参考文献<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<<<<<<< HEAD
<blockquote>
<div><a class="reference external" href="http://blog.csdn.net/vevenlcf/article/details/50600324">http://blog.csdn.net/vevenlcf/article/details/50600324</a></div></blockquote>
</div>
<div class="section" id="id5">
<h2>开源引擎借鉴<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<blockquote>
=======
<blockquote>
<div><a class="reference external" href="http://blog.csdn.net/vevenlcf/article/details/50600324">http://blog.csdn.net/vevenlcf/article/details/50600324</a></div></blockquote>
</div>
<div class="section" id="id5">
<h2>开源引擎借鉴<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<blockquote>
>>>>>>> 0b6744533e3fa724b7fd4af7b05fc93a27b97fb6
<div><div class="line-block">
<div class="line">支持协议维度识别和解析</div>
<div class="line">协议识别、解析插件化</div>
<div class="line">特征区分服务端和客户端</div>
</div>
</div></blockquote>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="review.html" class="btn btn-neutral float-right" title="源码笔记(3.2.1)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="quick_start.html" class="btn btn-neutral" title="快速使用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2016-2017, promise.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>